<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="ReplState" timestamp="1491665020956">{:repl-history {:ide [], :local [&quot;(let [i (ImageIO/read (File. \&quot;t.png\&quot;))]\n  (restrict-channel i 2))&quot; &quot;(let [i (ImageIO/read (File. \&quot;t.png\&quot;))]\n  (restrict-channel2 i 1))&quot; &quot;(let [i (ImageIO/read (File. \&quot;t.png\&quot;))]\n  (restrict-channel2 i 0))&quot; &quot;(factor-of? 5 10)&quot; &quot;(factor-of? 10 5)&quot; &quot;(factor-of? 10 100)&quot; &quot;(clojure.pprint/pprint\n  (for [n (range 30)]\n    [n (prime? n)]))&quot; &quot;(clojure.pprint/pprint\n  (for [n (range 1 30)]\n    [n (prime? n)]))&quot; &quot;(divided-ranges 0 10 5)&quot; &quot;(divided-ranges 1 10 5)&quot; &quot;(divided-ranges 1 11 5)&quot; &quot;(multi-prime-finder 0 100 1)&quot; &quot;(multi-prime-finder 0 100 10)&quot; &quot;(g/bench\n  (multi-prime-finder 0 10000000 1))&quot; &quot;(g/bench\n  (multi-prime-finder 0 100000000 1))&quot; &quot;(multi-prime-finder 0 100000000 1)&quot; &quot;(take-last 20 (multi-prime-finder 0 100000000 1))&quot; &quot;(take 5 (reverse (multi-prime-finder 0 100000000 1)))&quot; &quot;(g/bench\n  (doall (multi-prime-finder 0 100000000 1)))&quot; &quot;(g/bench\n  (doall (multi-prime-finder 0 1000000 1)))&quot; &quot;(g/bench\n  (doall (multi-prime-finder 0 1000000 2)))\n                             &quot; &quot;(multi-prime-finder 0 1000 10)\n                             &quot; &quot;(g/bench\n  (doall (multi-prime-finder 0 1000000 10)))\n                             &quot; &quot;(for [n (range 20)]\n  (+ 5 (rand-int (- 10 5))))&quot; &quot;(for [n (range 100)]\n  (+ 5 (rand-int (- 10 5))))&quot; &quot;(def a (new-producer\n         #{1 2 3 4 5}\n         100\n         1000 5000))&quot; &quot;(time\n  (for [s (range 101) l (range 101) o (range 101)\n        :when (and\n                 (= 100 (+ s l o))\n                 (= 100 (+ (* s 5) (* l 3) (* o 1/3))))]\n    [s l o]))&quot; &quot;(g/bench\n  (for [s (range 101) l (range 101) o (range 101)\n        :when (and\n                 (= 100 (+ s l o))\n                 (= 100 (+ (* s 5) (* l 3) (* o 1/3))))]\n    [s l o]))&quot; &quot;(g/bench\n  (for [s (range 101), l (range (- 101 s)) :let [o (- 100 s l)]\n        :when (= 100 (+ (* s 5) (* l 3) (* o 1/3)))]\n    [s l o]))&quot; &quot;(g/bench\n  (doall\n    (for [s (range 101) l (range 101) o (range 101)\n          :when (and\n                   (= 100 (+ s l o))\n                   (= 100 (+ (* s 5) (* l 3) (* o 1/3))))]\n      [s l o])))&quot; &quot;(g/bench\n  (doall\n    (for [s (range 101), l (range (- 101 s)) :let [o (- 100 s l)]\n          :when (= 100 (+ (* s 5) (* l 3) (* o 1/3)))]\n      [s l o])))&quot; &quot;(partition-by #(= \\ ) \&quot;abc d\&quot;)&quot; &quot; %&quot; &quot;(partition-by #(= % \\ ) \&quot;abc defg hij\&quot;)&quot; &quot;(split-with #(= % \\ ) test-name)&quot; &quot;(split-with #(not= % \\ ) test-name)&quot; &quot;(take-nth 2 (partition-by #(= % \\ ) test-name))&quot; &quot;(drop 1\n      (drop-last \n        (take-nth 2 (partition-by #(= % \\ ) test-name))))&quot; &quot;(mapcat #(apply str %)\n  (drop 1\n        (drop-last \n          (take-nth 2 (partition-by #(= % \\ ) test-name)))))&quot; &quot;(map #(apply str %)\n  (drop 1\n        (drop-last \n          (take-nth 2 (partition-by #(= % \\ ) test-name)))))&quot; &quot;(middle-name \&quot;Brendon Taylor Williams\&quot;)&quot; &quot;(clojure.string/join\n  (drop 1\n        (drop-last \n          (take-nth 2 (partition-by #(= % \\ ) test-name)))))&quot; &quot;(middle-name test-name)&quot; &quot;(middle-name \&quot;Brendon Williams\&quot;)&quot; &quot;(dotimes [n 10]\n  (println n))&quot; &quot;(let [a (future\n          (dotimes [n 10]\n            (println n)))])&quot; &quot;(future\n  (dotimes [n 10]\n    (println n)))&quot; &quot;(def a (new-producer))&quot; &quot;(new-producer #{1 2 3} 20 500 1000)&quot; &quot;(def a (new-producer #{1 2 3} 20 500 1000))&quot; &quot;(def at (atom []))\n(let [n-to-produce 10\n      min-wait 500\n      max-wait 1000\n      item-set #{1 2 3}]\n  (future\n    (dotimes [_ n-to-produce]\n      (println \&quot;Produced!\&quot;)\n      (Thread/sleep (+ min-wait (rand-int (- max-wait min-wait))))\n      (swap! at #(conj % (rand-nth item-set))))))&quot; &quot;@at&quot; &quot;(def at (atom []))\n(let [n-to-produce 10\n      min-wait 0\n      max-wait 1\n      item-set #{1 2 3}]\n  (future\n    (dotimes [_ n-to-produce]\n      (println \&quot;Produced!\&quot;)\n      (Thread/sleep (+ min-wait (rand-int (- max-wait min-wait))))\n      (swap! at #(conj % (rand-nth item-set))))))&quot; &quot;(def at (atom []))\n(let [n-to-produce 10\n      item-set #{1 2 3}]\n  (future\n    (dotimes [_ n-to-produce]\n      (println \&quot;Produced!\&quot;)\n      (swap! at #(conj % (rand-nth item-set))))))&quot; &quot;(def at (atom []))\n\n(let [n-to-produce 10\n      item-set #{1 2 3}]\n  (future\n    (dotimes [_ n-to-produce]\n      (println \&quot;Produced!\&quot;)\n      #_(swap! at #(conj % (rand-nth item-set))))))&quot; &quot;(def at (atom []))\n\n(let [n-to-produce 10\n      item-set #{1 2 3}]\n  (future\n    (dotimes [_ n-to-produce]\n      (swap! at #(conj % (rand-nth item-set)))\n      (println \&quot;Produced!\&quot;))))&quot; &quot;(def at (atom []))\n\n(let [n-to-produce 10\n      item-set #{1 2 3}]\n  (println \\! (rand-nth item-set))\n  (future\n    (dotimes [_ n-to-produce]\n      (swap! at #(conj % (rand-nth item-set)))\n      (println \&quot;Produced!\&quot;))))&quot; &quot;(def at (atom []))\n\n(let [item-set #{1 2 3}]\n  (future\n    (swap! at #(conj % (rand-nth item-set)))\n    (println \&quot;Produced!\&quot;)))&quot; &quot;(def at (atom []))\n\n(let [item-set #{1 2 3}]\n  (future\n    (println (rand-nth item-set))\n    (swap! at #(conj % (rand-nth item-set)))\n    (println \&quot;Produced!\&quot;)))&quot; &quot;(def at (atom []))\n\n(let [item-set #{1 2 3}]\n  (future (.toString null)))\n    &quot; &quot;(def at (atom []))\n\n(let [item-set #{1 2 3}]\n  (future (.toString nil)))\n    &quot; &quot;(.toString nil)&quot; &quot;(future\n  (.toString nil))&quot; &quot;@\n(future\n  (.toString nil))&quot; &quot;@\n  (future\n    (.toString nil))&quot; &quot;(def at (atom []))\n\n(let [item-set #{1 2 3}\n      f (future\n          (println (rand-nth item-set))\n          (swap! at #(conj % (rand-nth item-set)))\n          (println \&quot;Produced!\&quot;)\n          @f)])\n      \n      &quot; &quot;(thread\n  (while true\n    (println \\!)))&quot; &quot;@a&quot; &quot;(def a (new-producer #{ 1 2 3} 100 250 5000))&quot; &quot;(def a (new-producer #{ 1 2 3} 100 250 1000))&quot; &quot;(def a (new-producer #{ 1 2 3} -1 250 500))&quot; &quot;(timeout 500 1000\n  (+ 1 2))\n  &quot; &quot;(timeout 500 1000\n  (Thread/sleep 900)\n  (+ 1 2))\n  &quot; &quot;(timeout 500 1000\n  (Thread/sleep 450)\n  (+ 1 2))\n  &quot; &quot;(timeout 500 1000\n  (Thread/sleep 490)\n  (+ 1 2))\n  &quot; &quot;(for [n (range 100)]\n  (clojure.pprint/pprint\n    (timeout 500 1000\n      (Thread/sleep 490)\n      (+ 1 2))))\n  &quot; &quot;(let [producer-queue (new-producer\n                       (vec (range 100))\n                       -1\n                       250 1000)]\n  \n  (g/thread (while true\n              (Thread/sleep 2500)\n              (println @producer-queue)))\n  \n  (new-consumer producer-queue\n                300 1200))&quot; &quot;(let [producer-queue (new-producer\n                       (vec (range 100))\n                       -1\n                       250 1000)]\n  \n  (g/thread (while true\n              (Thread/sleep 2500)\n              (println @producer-queue)))\n  \n  (println \&quot;Starting consumer...\&quot;)\n  (new-consumer producer-queue\n                300 1200))&quot; &quot;(let [producer-queue (new-producer\n                       (vec (range 100))\n                       -1\n                       250 1000)]\n  #_\n  (g/thread (while true\n              (Thread/sleep 2500)\n              (println @producer-queue)))\n  \n  (println \&quot;Starting consumer...\&quot;)\n  (new-consumer producer-queue\n                300 1200))&quot; &quot;(let [producer-queue (new-producer\n                       (vec (range 100))\n                       -1\n                       250 1000)]\n  (g/thread (while true\n              (Thread/sleep 2500)\n              (println @producer-queue)))\n  \n  (println \&quot;Starting consumer...\&quot;)\n  (new-consumer producer-queue\n                300 1200))&quot; &quot;(let [producer-queue (new-producer\n                       (vec (range 100))\n                       -1\n                       1000 1000)]\n  (g/thread (while true\n              (Thread/sleep 2500)\n              (println @producer-queue)))\n  \n  (println \&quot;Starting consumer...\&quot;)\n  (new-consumer producer-queue\n                1000 1010))&quot; &quot;(let [producer-queue (new-producer\n                       (vec (range 100))\n                       -1\n                       3000 3000)]\n  (g/thread (while true\n              (Thread/sleep 2500)\n              (println @producer-queue)))\n  \n  (println \&quot;Starting consumer...\&quot;)\n  (new-consumer producer-queue\n                4000 4010))&quot; &quot;(into-array Byte/TYPE (range 128))\n&quot; &quot;(slurp (into-array Byte/TYPE (range 128)))\n&quot; &quot;(slurp \&quot;./t.png\&quot;)\n&quot; &quot;(spit \&quot;Desktop\&quot;\n  (slurp \&quot;./t.png\&quot;))\n&quot; &quot;(spit \&quot;C:/Users/slomi/IdeaProjects/bits/outputs\&quot;\n  (slurp \&quot;./t.png\&quot;))\n&quot; &quot;(spit \&quot;C:/Users/slomi/IdeaProjects/bits/outputs/t.png\&quot;\n  (slurp \&quot;./t.png\&quot;))\n&quot; &quot;(spit (into-array Byte/TYPE \&quot;C:/Users/slomi/IdeaProjects/bits/outputs/t.png\&quot;)\n  (slurp \&quot;./t.png\&quot;))\n&quot; &quot;(spit \&quot;C:/Users/slomi/IdeaProjects/bits/outputs/t.png\&quot;\n  (into-array Byte/TYPE (slurp \&quot;./t.png\&quot;)))\n&quot; &quot;(get-bytes \&quot;./t.png\&quot;)\n&quot; &quot;((get-bytes \&quot;./t.png\&quot;))\n&quot; &quot;(spit \&quot;C:/Users/slomi/IdeaProjects/bits/outputs/t.png\&quot;\n  (get-bytes \&quot;./t.png\&quot;))\n&quot; &quot;(clojure.pprint/pprint\n  (get-bytes \&quot;./t.png\&quot;))\n&quot; &quot;(type (get-bytes \&quot;./t.png\&quot;))\n&quot; &quot;(write-byte (get-bytes \&quot;./t.png\&quot;))\n&quot; &quot;(write-bytes \&quot;C:/Users/slomi/IdeaProjects/bits/outputs/t.png\&quot;\n  (get-bytes \&quot;./t.png\&quot;))\n&quot; &quot;java.lang.Process&quot; &quot;(.available\n  (FileInputStream. (File. \&quot;./t.png\&quot;)))\n&quot; &quot;(.length (File. \&quot;./t.png\&quot;))\n&quot; &quot;(write-bytes-to-file \&quot;C:/Users/slomi/IdeaProjects/bits/outputs/t.png\&quot;\n  (read-bytes-from-file \&quot;./t.png\&quot;))\n&quot;], :remote []}}</component>
</project>